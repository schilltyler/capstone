
**Overview:** Implement a C program that uses the `ptrace` system call on AArch64 Linux to inject a shared object (`.so` file) into a running target process. This involves manipulating the target process's registers and memory to force it to call `dlopen()`.
 
Process injection is a technique where one process forces another process to load and execute code. `ptrace` provides the necessary capabilities to pause a target process, inspect and modify its state (registers and memory), and resume its execution. This assignment focuses on using `ptrace` to make a target process load a dynamic library, effectively injecting the library's code.

pre-req:

- `man ptrace` system call (attaching, reading/writing registers/memory, continuing execution).
- Review AArch64 Application Binary Interface (ABI), particularly register usage for function calls (x0-x7 for arguments, x0 for return, x30 for Link Register (LR), PC for Program Counter).
- `man {dlopen, dlsym, mmap}`, shared object loading).
- Address Space Layout Randomization (ASLR) and calculating remote function addresses.
- `man procfs`.
- **Note:** Running `ptrace` often requires root privileges or specific capabilities (`CAP_SYS_PTRACE`). Run your compiled program with `sudo`.

**Tasks:**

Implement the following functions step-by-step. Test incrementally where possible.

1. **Basic ptrace Wrappers and Helpers (`ptrace_getregs`, `ptrace_setregs`, `print_regs`, `print_status`):**
    
    - Implement `ptrace_getregs` and `ptrace_setregs`. These functions will wrap the `ptrace` call with `PTRACE_GETREGSET` and `PTRACE_SETREGSET` respectively, using the `NT_PRSTATUS` argument to specify the general-purpose registers. Use the `struct iovec` as shown in the original code comments/example. Remember to handle potential errors.
    - Implement `print_regs`. This is a debugging helper to print the values of key registers (e.g., x0-x7, LR, SP, PC, PSTATE) from a `user_pt_regs` struct. This will be invaluable for debugging the state of the target process.
    - Implement `print_status`. This function takes the status value returned by `waitpid` and uses the `WIF*` macros (e.g., `WIFSTOPPED`, `WSTOPSIG`, `WIFEXITED`, `WEXITSTATUS`) to print a human-readable description of why the target process stopped or exited.
2. **Address Calculation (`get_local_libc_base`, `get_remote_libc_base`):**
    
    - Implement `get_local_libc_base`. Use `dladdr` on a known libc function (like `mmap` or `printf`) to find the base address of the loaded libc library _in your injector process_. This is needed as a reference point. Handle errors if `dladdr` fails.
    - Implement `get_remote_libc_base`. This function needs to find the base address of libc _in the target process_. The common way is to parse the `/proc/<pid>/maps` file for the target process ID (`pid`). Look for lines containing "libc" (or more specifically, like "libc-_.so" or "libc.so._") and having execute permissions (`r-xp`). Extract the starting address from the matching line. Handle file opening/reading errors.
3. **Remote Function Call (`remote_call`):** This is the most complex part. It simulates calling a function within the target process.
    
    - **Save State:** Get and save the target process's current registers using `ptrace_getregs`. Keep a copy of these original registers.
    - **Determine Return Address:** Use the original Link Register (`regs.regs[30]`) as the address where the remote function _should_ return.
    - **Set Breakpoint:**
        - Read the original instruction word at the chosen return address using `ptrace(PTRACE_PEEKTEXT, ...)`. Store this original word.
        - Write a breakpoint instruction (`brk #0`,) to the return address using `ptrace(PTRACE_POKETEXT, ...)`. 
         
        **Important:** This might fail if the page has the wrong memory protections. The provided code includes a note about this; for this assignment, assume it works or choose a target where it's less likely to be an issue (or explore workarounds like trampolines if necessary, though that's beyond the basic scope here).
    - **Setup Call:**
        - Modify the _saved_ register state (not the original copy):
            - Set `regs.pc` to the address of the function you want to call (`func`).
            - Set argument registers `regs.regs[0]` through `regs.regs[5]` to `arg0` through `arg5`.
            - Set the Link Register `regs.regs[30]` to the `ret_addr` where you placed the breakpoint.
        - Set the target process's registers to this modified state using `ptrace_setregs`.
    - **Execute & Wait:** Continue the target process using `ptrace(PTRACE_CONT, ...)` and immediately call `waitpid` to wait for it to stop again.
    - **Check Stop Reason:** Verify that the process stopped because of a `SIGTRAP` signal (which is generated by the `brk` instruction). 
    - Use `print_status` for debugging. If it didn't stop with SIGTRAP, something went wrong.
    - **Get Return Value:** Get the target's registers again (`ptrace_getregs`). The return value of the called function will typically be in `regs.regs[0]`. Store this value.
    - **Restore State:**
        - Restore the original instruction word at the return address using `ptrace(PTRACE_POKETEXT, ...)`.
        - Restore the target's registers to their _original_ state (the copy you saved at the beginning) using `ptrace_setregs`.
    - **Return:** Return the captured return value (from `regs.regs[0]` after the call). Remember to handle errors throughout the function.
4. **Shared Object Injection Logic (`inject_so`):** This function orchestrates the overall injection process.
    
    - **Attach:** Attach to the `target_pid` using `ptrace(PTRACE_ATTACH, ...)` and `waitpid` for the process to stop. Check the status.
    - **Calculate Addresses:**
        - Call `get_local_libc_base` and `get_remote_libc_base` to get the base addresses.
        - Use `dlsym(RTLD_DEFAULT, "dlopen")` to get the address of `dlopen` in the _injector_ process. Calculate the address of `dlopen` in the _target_ process using the formula: `remote_dlopen = remote_libc + (local_dlopen - local_libc)`.
        - Do the same to calculate the `remote_mmap` address based on the local `mmap` address.
    - **Allocate Memory in Target:**
        - Call your `remote_call` function to execute `mmap` _in the target process_. Pass the calculated `remote_mmap` address as the function to call.
        - Arguments for `mmap` (check `man mmap`): `addr=0` (let kernel choose), `length=4096` (enough space for the path), `prot=PROT_READ | PROT_WRITE`, `flags=MAP_PRIVATE | MAP_ANONYMOUS`, `fd=-1`, `offset=0`.
        - Check the return value from `remote_call` (which is the result of `mmap`). It should be a valid memory address. Handle errors (e.g., if it returns 0 or an error code like -1 cast to unsigned long).
    - **Write SO Path:**
        - Write the absolute path`so_path` string into the newly allocated remote buffer. Use a loop and `ptrace(PTRACE_POKETEXT, ...)` to write the path word-by-word (e.g., `sizeof(long)` bytes at a time). Remember to include the null terminator!!!
    - **Call Remote `dlopen`:**
        - Call `remote_call` again. This time, the function to call is `remote_dlopen`.
        - The first argument (`arg0`) is the address of the remote buffer containing the `so_path`.
        - The second argument (`arg1`) is the flags for `dlopen`, typically `RTLD_NOW | RTLD_GLOBAL`.
        - Other arguments (arg2-arg5) can be 0.
        - Check the return value (the handle returned by `dlopen`). A null handle (0) indicates failure.
    - **Detach:** Detach from the target process using `ptrace(PTRACE_DETACH, ...)`.
    - **Return:** Return 0 on success, -1 on failure.
5. **Compilation and Testing:**
    
    - Compile your code using GCC:
        
        Bash
        
        ```
        gcc -o inject inject.c -ldl -Wall -Wextra
        ```
        
    - **Create a Test Shared Object:** Create a simple `.so` file (e.g., `libtest.c`) with a constructor function that prints a message:
        
        C
        
        ```
        // libtest.c
        #include <stdio.h>
        
        __attribute__((constructor))
        void injected_entry() {
            printf("[+] Hello from injected library!\n");
        
        }
        ```
        
        Compile it:
        
        Bash
        
        ```
        gcc -shared -fPIC -o libtest.so libtest.c
        ```
        
    - **Create a Target Process:** A simple process that loops is sufficient:
        
        
        ```
        ping 1.1.1.1 &
        sudo ./injector ./libtest.so `pidof ping`
        pkill -9 ping #(done)
        ```
        
        (You likely need `sudo`). Observe the output from both the injector and the target process. If successful, you should see the 
        `"[+] Hello from injected library!"` message appear in the target's output stream.

**Submission:** Submit your completed C source code file (`.c`). Ensure it compiles cleanly with `-Wall -Wextra`.


## Placeholder C Code for Students

C

```
#define _GNU_SOURCE
#include <dlfcn.h>
#include <errno.h>
#include <linux/elf.h> // For NT_PRSTATUS
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/uio.h> // For struct iovec
#include <sys/user.h> // For user_pt_regs (may be needed depending on exact headers)
#include <sys/wait.h>
#include <unistd.h>

// Define AArch64 register structure. Matches kernel definition.
struct user_pt_regs {
    uint64_t regs[31]; // x0 - x30 (x30 is LR)
    uint64_t sp;
    uint64_t pc;
    uint64_t pstate;
};

// Function Prototypes (To be implemented by the student)
void print_regs(const char *msg, struct user_pt_regs *regs);
int ptrace_getregs(pid_t pid, struct user_pt_regs *regs);
int ptrace_setregs(pid_t pid, struct user_pt_regs *regs);
void print_status(int status);
unsigned long get_remote_libc_base(pid_t pid);
unsigned long get_local_libc_base();
unsigned long remote_call(pid_t pid, unsigned long func, unsigned long arg0,
                          unsigned long arg1, unsigned long arg2,
                          unsigned long arg3, unsigned long arg4,
                          unsigned long arg5);
int inject_so(pid_t target_pid, const char *so_path);

// --- Implementation Starts Here ---

// Task 1: Basic ptrace Wrappers and Helpers
void print_regs(const char *msg, struct user_pt_regs *regs) {
    printf("==== %s ====\n", msg);
    // TODO: Implement printing of relevant registers (x0-x7, LR, SP, PC, PSTATE)
    // Example for first few registers:
    // for (int i = 0; i < 8; i++) {
    //     printf("x%d: 0x%lx ", i, regs->regs[i]);
    // }
    // printf("\n");
    // printf("lr (x30): 0x%lx\n", regs->regs[30]);
    // printf("sp: 0x%lx\n", regs->sp);
    // printf("pc: 0x%lx\n", regs->pc);
    // printf("pstate: 0x%lx\n", regs->pstate);

    printf("  [!] print_regs: Not fully implemented yet.\n"); // Placeholder
    printf("==== End %s ====\n", msg);
}

int ptrace_getregs(pid_t pid, struct user_pt_regs *regs) {
    // TODO: Implement using ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov)
    // struct iovec iov = {regs, sizeof(*regs)};
    fprintf(stderr, "[!] ptrace_getregs: Not implemented yet.\n"); // Placeholder
    errno = ENOSYS; // Indicate not implemented
    return -1; // Placeholder
}

int ptrace_setregs(pid_t pid, struct user_pt_regs *regs) {
    // TODO: Implement using ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &iov)
    // struct iovec iov = {regs, sizeof(*regs)};
    fprintf(stderr, "[!] ptrace_setregs: Not implemented yet.\n"); // Placeholder
    errno = ENOSYS; // Indicate not implemented
    return -1; // Placeholder
}

void print_status(int status) {
    // TODO: Implement using WIFSTOPPED, WSTOPSIG, WIFEXITED, WEXITSTATUS etc.
    printf("[*] Wait status: 0x%x (print_status not fully implemented)\n", status); // Placeholder
}

// Task 2: Address Calculation
unsigned long get_remote_libc_base(pid_t pid) {
    // TODO: Implement parsing /proc/<pid>/maps
    // Look for the line containing "libc" and "r-xp" permission.
    // Extract the starting address.
    fprintf(stderr, "[!] get_remote_libc_base: Not implemented yet.\n"); // Placeholder
    return 0; // Placeholder
}

unsigned long get_local_libc_base() {
    // TODO: Implement using dladdr() on a known libc function (e.g., mmap).
    // Dl_info info;
    // if (dladdr((void *)mmap, &info)) { return (unsigned long)info.dli_fbase; }
    fprintf(stderr, "[!] get_local_libc_base: Not implemented yet.\n"); // Placeholder
    return 0; // Placeholder
}

// Task 3: Remote Function Call
unsigned long remote_call(pid_t pid, unsigned long func, unsigned long arg0,
                          unsigned long arg1, unsigned long arg2,
                          unsigned long arg3, unsigned long arg4,
                          unsigned long arg5) {
    struct user_pt_regs regs, original_regs;
    int status;
    unsigned long retval = 0;
    unsigned long ret_addr = 0;
    long orig_word = 0;
    long brk_instr = 0xd4200000; // brk #0

    fprintf(stderr, "[!] remote_call: Not implemented yet.\n"); // Placeholder

    // Steps:
    // 1. ptrace_getregs(pid, &original_regs)
    // 2. memcpy(&regs, &original_regs, sizeof(regs))
    // 3. ret_addr = original_regs.regs[30] (LR)
    // 4. orig_word = ptrace(PTRACE_PEEKTEXT, pid, ret_addr, NULL)
    // 5. ptrace(PTRACE_POKETEXT, pid, ret_addr, brk_instr)
    // 6. Setup call registers in 'regs': pc=func, regs[0-5]=args, regs[30]=ret_addr
    // 7. ptrace_setregs(pid, &regs)
    // 8. ptrace(PTRACE_CONT, pid, NULL, NULL)
    // 9. waitpid(pid, &status, 0)
    // 10. Check status (should be stopped by SIGTRAP at ret_addr)
    // 11. ptrace_getregs(pid, &regs)
    // 12. retval = regs.regs[0]
    // 13. ptrace(PTRACE_POKETEXT, pid, ret_addr, orig_word) // Restore instruction
    // 14. ptrace_setregs(pid, &original_regs) // Restore original state
    // 15. Return retval

    // Remember error checking for all ptrace calls and waitpid!

    errno = ENOSYS;
    return (unsigned long)-1; // Placeholder for error
}

// Task 4: Shared Object Injection Logic
int inject_so(pid_t target_pid, const char *so_path) {
    int status;
    long ret = -1; // Default to failure
    unsigned long remote_libc = 0;
    unsigned long local_libc = 0;
    void *local_dlopen = NULL;
    unsigned long remote_dlopen = 0;
    void *local_mmap = NULL;
    unsigned long remote_mmap = 0;
    unsigned long remote_buf = 0;
    size_t so_len = strlen(so_path) + 1;
    unsigned long handle = 0;

    printf("[+] Attaching to process %d\n", target_pid);
    if (ptrace(PTRACE_ATTACH, target_pid, NULL, NULL) == -1) {
        perror("[-] ptrace ATTACH");
        return -1;
    }
    waitpid(target_pid, &status, 0);
    print_status(status);
    if (!WIFSTOPPED(status)) {
        fprintf(stderr, "[-] Process not stopped after attach\n");
        goto detach; // Use goto for cleanup on failure
    }

    fprintf(stderr, "[!] inject_so: Core logic not implemented yet.\n"); // Placeholder

    // Steps:
    // 1. Get local and remote libc base addresses
    // 2. Calculate remote dlopen and mmap addresses
    // 3. Use remote_call to invoke mmap in target -> get remote_buf address
    // 4. Check if remote_buf is valid
    // 5. Write so_path to remote_buf using PTRACE_POKETEXT (word by word)
    // 6. Use remote_call to invoke dlopen(remote_buf, flags) in target
    // 7. Check the returned handle
    // 8. Set ret = 0 on success

    // Remember error checking!

detach: // Label for cleanup
    printf("[+] Detaching from process %d\n", target_pid);
    if (ptrace(PTRACE_DETACH, target_pid, NULL, NULL) == -1) {
        perror("[-] ptrace DETACH");
        // If detach fails, the overall operation likely failed anyway
        ret = -1;
    }
    return ret;
}

// --- Main Function (Provided) ---
int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <shared_object.so> <pid>\n", argv[0]);
        return 1;
    }
    const char *so_path = argv[1];
    pid_t target_pid = atoi(argv[2]); // Consider using strtol for better error checking

    if (target_pid <= 0) {
        fprintf(stderr, "Invalid PID: %s\n", argv[2]);
        return 1;
    }

    // Check if the .so file exists and is accessible (optional but good practice)
    if (access(so_path, R_OK) != 0) {
        perror("[-] Cannot access shared object file");
        fprintf(stderr, "    Path: %s\n", so_path);
        return 1;
    }

    printf("[*] Injector starting...\n");
    printf("[*] Target PID: %d\n", target_pid);
    printf("[*] Shared object path: %s\n", so_path);

    int result = inject_so(target_pid, so_path);

    if (result == 0) {
        printf("[+] Shared object injection completed successfully.\n");
    } else {
        fprintf(stderr, "[-] Shared object injection failed.\n");
    }

    return (result == 0) ? 0 : 1;
}
```