
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Baby's Your First Malware!
:::

- Suppose we have a suspicious ELF binary: `clickMe`  
-  hash:  
  <small>`8df373d828cf0c98b949212971fc20a53959fe5792e952011242e32561bfa797`</small>


---

<!-- slide template="[[Split Vertical]]" -->
::: title
#### Imports (Dynamic Symbols)
:::

::: left
<!-- element style="font-size: 24px"-->
- Many ELF binaries import symbols from `.so` libraries
- Think of them like “imports” in Python
- Tools: `readelf -Ws`, `objdump -T`, Ghidra’s “Imports” tab
:::

::: right
```
ldd sample 
	linux-vdso.so.1 (0x00007fff38448000)
	libcurl.so.4 => /lib/aarch64-linux-gnu/libcurl.so.4 (0x00007fff38300000)
	libc.so.6 => /lib/aarch64-linux-gnu/libc.so.6 (0x00007fff38140000)
	libnghttp2.so.14 => /lib/aarch64-linux-gnu/libnghttp2.so.14 (0x00007fff380f0000)
	libidn2.so.0 => /lib/aarch64-linux-gnu/libidn2.so.0 (0x00007fff380a0000)
	librtmp.so.1 => /lib/aarch64-linux-gnu/librtmp.so.1 (0x00007fff38060000)
	libssh2.so.1 => /lib/aarch64-linux-gnu/libssh2.so.1 (0x00007fff38000000)
	libpsl.so.5 => /lib/aarch64-linux-gnu/libpsl.so.5 (0x00007fff37fc0000)
	libssl.so.3 => /lib/aarch64-linux-gnu/libssl.so.3 (0x00007fff37f00000)
	libcrypto.so.3 => /lib/aarch64-linux-gnu/libcrypto.so.3 (0x00007fff37a80000)
	libgssapi_krb5.so.2 => /lib/aarch64-linux-gnu/libgssapi_krb5.so.2 (0x00007fff37a10000)
	libldap-2.5.so.0 => /lib/aarch64-linux-gnu/libldap-2.5.so.0 (0x00007fff37990000)
	liblber-2.5.so.0 => /lib/aarch64-linux-gnu/liblber-2.5.so.0 (0x00007fff37960000)
	libzstd.so.1 => /lib/aarch64-linux-gnu/libzstd.so.1 (0x00007fff378a0000)
	libbrotlidec.so.1 => /lib/aarch64-linux-gnu/libbrotlidec.so.1 (0x00007fff37870000)
	libz.so.1 => /lib/aarch64-linux-gnu/libz.so.1 (0x00007fff37830000)
	/lib/ld-linux-aarch64.so.1 (0x00007fff38410000)
	libunistring.so.2 => /lib/aarch64-linux-gnu/libunistring.so.2 (0x00007fff37660000)
	libgnutls.so.30 => /lib/aarch64-linux-gnu/libgnutls.so.30 (0x00007fff37410000)
	libhogweed.so.6 => /lib/aarch64-linux-gnu/libhogweed.so.6 (0x00007fff373a0000)
	libnettle.so.8 => /lib/aarch64-linux-gnu/libnettle.so.8 (0x00007fff37330000)
	libgmp.so.10 => /lib/aarch64-linux-gnu/libgmp.so.10 (0x00007fff37290000)
	libkrb5.so.3 => /lib/aarch64-linux-gnu/libkrb5.so.3 (0x00007fff371a0000)
	libk5crypto.so.3 => /lib/aarch64-linux-gnu/libk5crypto.so.3 (0x00007fff37150000)
	libcom_err.so.2 => /lib/aarch64-linux-gnu/libcom_err.so.2 (0x00007fff37120000)
	libkrb5support.so.0 => /lib/aarch64-linux-gnu/libkrb5support.so.0 (0x00007fff370f0000)
	libsasl2.so.2 => /lib/aarch64-linux-gnu/libsasl2.so.2 (0x00007fff370b0000)
	libbrotlicommon.so.1 => /lib/aarch64-linux-gnu/libbrotlicommon.so.1 (0x00007fff37070000)
	libp11-kit.so.0 => /lib/aarch64-linux-gnu/libp11-kit.so.0 (0x00007fff36f20000)
	libtasn1.so.6 => /lib/aarch64-linux-gnu/libtasn1.so.6 (0x00007fff36ee0000)
	libkeyutils.so.1 => /lib/aarch64-linux-gnu/libkeyutils.so.1 (0x00007fff36eb0000)
	libresolv.so.2 => /lib/aarch64-linux-gnu/libresolv.so.2 (0x00007fff36e80000)
	libffi.so.8 => /lib/aarch64-linux-gnu/libffi.so.8 (0x00007fff36e50000)

```
:::

---

<!-- slide template="[[Split Vertical]]" -->
::: title
#### Imports
:::

::: left
- You can see the `.so` file name and the specific function symbols  
- On Linux: `libc.so.6` is very common (contains `printf`, `open`, etc.)  
- Notation might look like `GLIBC_2.27` or `_ZNSomeSymbol...`
- "mangled symbols" and de-mangling 
:::

::: right
```
objdump -T sample 

sample:     file format elf64-littleaarch64

DYNAMIC SYMBOL TABLE:
00000000000008d8 l    d  .init	0000000000000000              .init
0000000000020080 l    d  .data	0000000000000000              .data
0000000000000000      DF *UND*	0000000000000000 (GLIBC_2.17) fprintf
0000000000000000      DF *UND*	0000000000000000 (GLIBC_2.17) perror
0000000000000000      DF *UND*	0000000000000000 (GLIBC_2.17) fclose
0000000000000000  w   DF *UND*	0000000000000000 (GLIBC_2.17) __cxa_finalize
0000000000000000      DF *UND*	0000000000000000 (GLIBC_2.34) __libc_start_main
0000000000000000      DF *UND*	0000000000000000 (GLIBC_2.17) execve
0000000000000000      DF *UND*	0000000000000000 (GLIBC_2.17) chmod
0000000000000000      DF *UND*	0000000000000000 (CURL_OPENSSL_4) curl_easy_setopt
0000000000000000      DF *UND*	0000000000000000 (CURL_OPENSSL_4) curl_easy_cleanup
0000000000000000      DF *UND*	0000000000000000 (CURL_OPENSSL_4) curl_easy_init
0000000000000000      DF *UND*	0000000000000000 (CURL_OPENSSL_4) curl_easy_perform
0000000000000000      DF *UND*	0000000000000000 (GLIBC_2.17) fopen
0000000000000000      DF *UND*	0000000000000000 (CURL_OPENSSL_4) curl_easy_strerror
0000000000000000      DF *UND*	0000000000000000 (GLIBC_2.17) abort
0000000000000000  w   D  *UND*	0000000000000000  Base        _ITM_deregisterTMCloneTable
0000000000000000      DF *UND*	0000000000000000 (GLIBC_2.17) fwrite
0000000000000000  w   D  *UND*	0000000000000000  Base        __gmon_start__
0000000000000000      DO *UND*	0000000000000000 (GLIBC_2.17) stderr
0000000000000000  w   D  *UND*	0000000000000000  Base        _ITM_registerTMCloneTable

```

:::

---

<!-- slide template="[[Split Vertical]]" -->
::: title
#### Imports
:::

::: left
<!-- element style="font-size: 24px"-->
- For quick triage, `ldd` readelf -d` or `objdump -p` can show dynamic library dependencies
- For deeper analysis, Ghidra/radare2 can cross-reference calls into these libraries
:::

::: right


:::

---

<!-- slide template="[[Split Vertical]]" -->
::: title
#### Imports: Why Do We Care?
:::

::: left
- The set of imported functions often reveals **capabilities** of the malware  
  - e.g., `socket()`, `connect()`, `fork()`, `execve()`, `system()`, etc.  
- Linux processes can also **dynamically** load more .so libraries at runtime with `dlopen`. Keep that in mind.
- Further, many capabilities implemented in libraries can just as easily be implemented by the program (eg crypto)
:::

::: right
![[0x03_slide_33_image.png|900]]
:::

---

<!-- slide template="[[Base Slide]]" -->
::: title
#### Some Interesting Imports (Linux)
:::

- `libc.so.6` → `system`, `execve`, `fork`
- `libcurl.so` → `curl_easy_perform` (network comm)
- `libdl.so` → `dlopen`, `dlsym` (dynamic library loading)
- `libpthread.so` → `pthread_create` (multithreading)
- `libssl.so`, `libcrypto.so` → encryption & network comm

---

<!-- slide template="[[Base Slide]]" -->
::: title
#### Strings
:::

- Tools: `strings`, Ghidra’s “Search for Strings,” or radare2’s `iz` command
- Look for ASCII or Unicode text in the ELF
- You may find paths, suspicious commands, error messages, or even leftover debug info
- **Be aware**: Malware authors can (and often do) encrypt/obfuscate strings

---

<!-- slide template="[[Split Vertical]]" -->
::: title
#### Strings
:::
::: left
- Ghidra (or radare2) is best for *in-depth* analysis
- You can easily cross-reference where each string is used in code
:::
::: right
```
strings sample 
/lib/ld-linux-aarch64.so.1
_ITM_deregisterTMCloneTable
__gmon_start__
_ITM_registerTMCloneTable
curl_easy_cleanup
curl_easy_strerror
curl_easy_init
curl_easy_setopt
curl_easy_perform
chmod
perror
fopen
execve
__libc_start_main
stderr
fprintf
__cxa_finalize
fclose
fwrite
abort
libcurl.so.4
libc.so.6
CURL_OPENSSL_4
GLIBC_2.34
GLIBC_2.17
`BB9@
/tmp/psql
Failed to open file
https://evil.com.ch0nky.com/evil
curl_easy_perform() failed: %s
chmod failed
execve failed

```
:::

---

<!-- slide template="[[Split Vertical]]" -->
::: title
#### Sections
:::

::: left
- In ELF, data/code is organized into **sections**
- Typical ones:
  - `.text` → code
  - `.rodata` → read-only data
  - `.data` → global data
  - `.bss` → uninitialized data
  - `.comment`, `.note`, etc. → metadata
:::

::: right
```
objdump -h  sample 

sample:     file format elf64-littleaarch64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .interp       0000001b  0000000000000238  0000000000000238  00000238  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .note.gnu.build-id 00000024  0000000000000254  0000000000000254  00000254  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .note.ABI-tag 00000020  0000000000000278  0000000000000278  00000278  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .gnu.hash     0000001c  0000000000000298  0000000000000298  00000298  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .dynsym       00000210  00000000000002b8  00000000000002b8  000002b8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dynstr       00000137  00000000000004c8  00000000000004c8  000004c8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
...
```
:::

---

<!-- slide template="[[Split Vertical]]" -->
::: title
####  Embedded Data
:::

::: left
<!-- element style="font-size: 24px"-->
- ELF doesn’t have a “Resources” section like PE  
- However, malware can embed data directly in custom sections or as raw bytes in `.rodata`
- Tools: `binwalk` or Ghidra’s “Bytes” view  
- Many Linux malware families embed their config or payload in a custom section
:::

::: right
:::

---

<!-- slide template="[[Split Vertical]]" -->
::: title
#### Symbols / Debug Information
:::

::: left
- If compiled with `-g`, debug symbols might be included  
- Ghidra can parse these for function names/variables
- Sometimes you’ll see leftover references to `.c` or `.h` file paths (like “/home/user/project/main.c”)
:::

::: right

:::

---

<!-- slide template="[[Base Slide]]" -->
::: title
#### X-Refs (Cross References)
:::

- Large codebases can be confusing. Start by finding references to interesting functions or strings
- “Where is this suspicious string used?” or “Who calls `execve()`?”
- Tools: Ghidra right-click → “References”, radare2 → `axt`

---

<!-- slide template="[[Split Vertical]]" -->
::: title
#### X-Refs: Imports
:::

::: left
- Right click an imported function → “Show references”
- Great for tracing how the code calls `socket()` or `execve()`
:::

::: right
:::

---

<!-- slide template="[[Split Vertical]]" -->
::: title
#### X-Refs
:::

::: left
- Example: find references to suspicious network calls to identify malicious connections  
- Or track calls to `dlopen` to see if additional .so files are loaded dynamically
:::

::: right
![[0x03_slide_42_image.png|300]]
:::

---

<!-- slide template="[[Base Slide]]" -->
::: title
#### X-Refs: Strings
:::

![[0x03_slide_43_image.png|800]]

---

<!-- slide template="[[Base Slide]]" -->
::: title
#### X-Refs: Strings
:::


---

<!-- slide template="[[Base Slide]]" -->
::: title
#### Reading/Editing Assembly
:::

- Ghidra includes a decent **decompiler** for AArch64 → produces C-like pseudocode  
- Also supports interactive disassembly  
- Rename functions, annotate variables, comment… then save to your Ghidra project  

---

<!-- slide template="[[Split Vertical]]" -->
::: title
#### Reading/Editing Assembly
:::

::: left
- Use “Display Control Flow Graph” in Ghidra to see how the function branches
:::

::: right
![[0x03_slide_46_image.png|300]]
:::

---

<!-- slide template="[[Base Slide]]" -->
::: title
#### Reading/Editing Assembly
:::

![[0x03_slide_47_image.png|400]]
